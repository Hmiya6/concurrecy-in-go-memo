# 競合状態とアトミック性

## 競合状態
> 2つ以上の操作が正しい順番で実行されなければいけないところで、プログラムが**順序を保障するように書かれていなかった**ときに発生します。

強調は引用者.

### 競合状態が発生するコード
```go
var data int  // initialized by 0
go func() {
    data++  // access to data ... (1)
}()
if data == 0 {  // access to data ... (2)
    fmt.Printf("the value is %v\n", data)  // access to data ... (3)
}
```
並行処理をする (1) が**どのタイミングで実行されるか**によって結果が変化.

起こりうる結果
* 何も表示されない. すなわち (1)が(2)の前に実行される.  
(1) -> (2) -> (3)
* "the value is 1" が表示される. すなわち (1)が(2)と(3)の間で実行される.   
(2) -> (1) -> (3)
* "the value is 0" が表示される. すなわち (1)が(3)の後に実行される.  
(2) -> (3) -> (1)


---
## アトミック性

> 何かがアトミック、あるいはアトミック性があると考えられる場合、それが操作されている特定のコンテキストの中では分割不能、あるいは中断不能であることを意味します。

つまり、アトミックであるとは、  
    1. **特定のコンテキスト**の中で、
    2. **分割不能、中断不能**である  
ということ

ここで、コンテキストとは、OSやプログラミング言語、アプリケーションを指し示す.  

### 例) `i++` のアトミック性について  
プログラミング言語というコンテキスト(文脈)では `i++` はアトミックな処理に**見える**が、  
ほかの文脈からは
* `i` の値を取得する
* `i` の値を 1 増やす
* `i` の値を保存する

という処理に**分割可能**である

このことからも分かるように、ある操作のアトミック性は**コンテキストに依存**している.

### Go のコンテキスト
Go のコンテキストで考えると、
ほかのゴルーチンとのデータのやり取りが必要な操作や関数はアトミックではない

### Q. なぜアトミック性が必要か
A. アトミックであれば、それを複数の並行なコンテキストで安全に扱えることが暗黙に保証されるから.

---
## 一応の解決方法
`data` にアクセスする場合にはメモリをロックし、排他的アクセスを可能にする.  
ただし、メモリロックによってデータ競合や論理的正当性は解決されるとは限らない (この例でも、(1)と(2)のどちらが先に実行されるかは確定できない).  
また、保守性や性能の問題が発生する(`data` にアクセスするたびにメモリロックを**忘れずに**しなければならない).
```go
var memoryAccess sync.Mutex
var data int
go func() {
    memoryAccess.Lock()
    data++ // (1)
    memoryAccess.Unlock()
}()
memoryAccess.Lock()
if data == 0 { // (2)
    fmt.Printf("the value is %v\n", data)
}
memoryAccess.Unlock()
```